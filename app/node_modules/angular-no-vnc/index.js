import angular from 'angular'
import {
  format as formatUrl,
  parse as parseUrl,
  resolve as resolveUrl
} from 'url'
import {RFB} from 'novnc-node'

import view from './view'

// ===================================================================

function parseRelativeUrl (url) {
  /* global window: false */
  return parseUrl(resolveUrl(String(window.location), url))
}

const PROTOCOL_ALIASES = {
  'http:': 'ws:',
  'https:': 'wss:'
}

function fixProtocol (url) {
  let protocol = PROTOCOL_ALIASES[url.protocol]

  if (protocol) {
    url.protocol = protocol
  }
}

// ===================================================================

export default angular.module('no-vnc', [])
  .controller('NoVncCtrl', function ($attrs, $element, $scope, $timeout) {
    this.height = 480
    $attrs.$observe('height', (height) => {
      this.height = height
    })
    this.width = 640
    $attrs.$observe('width', (width) => {
      this.width = width
    })

    const retrySteps = {
      0: 1000,
      1: 3000,
      2: 5000,
      3: 5000
    }
    let retryStep = 0
    let rfb
    let reconnectTry
    function clean () {
      // If there was a previous connection.
      if (rfb) {
        rfb._onUpdateState = () => {}
        rfb.disconnect()
        rfb = undefined
      }
    }

    function reset (url) {
      // Remove previous connection.
      clean()

      // If the URL is empty, stop now.
      if (!url) {
        return
      }

      // Parse the URL.
      url = parseRelativeUrl(url)
      fixProtocol(url)

      let isSecure = url.protocol === 'wss:'

      let canvas = $element.find('canvas')[0]
      rfb = new RFB({
        encrypt: isSecure,
        target: canvas,
        wsProtocols: ['chat'],
        onClipboard (rfb, text) {
          setClipboard(text)
        }
      })

      rfb._onUpdateState = (rfb, state) => {
        if (state === 'normal') {
          retryStep = 0
          if (reconnectTry) {
            $timeout.cancel(reconnectTry)
            reconnectTry = undefined
          }
        }
        if (state !== 'disconnected') {
          return
        }
        if (retryStep in retrySteps) {
          reconnectTry = $timeout(() => reset(url), retrySteps[retryStep++])
        }
      }

      // Connect.
      rfb.connect(formatUrl(url))
    }

    this.remoteControl = {
      pasteToClipboard (text) {
        if (rfb) {
          rfb.clipboardPasteFrom(text)
        }
      },
      sendCtrlAltDel () {
        if (rfb) {
          rfb.sendCtrlAltDel()
        }
      }
    }

    const setClipboard = (text) => {
      this.onClipboardChange({ clipboardContent: text })
    }

    $scope.unfocus = () => {
      if (rfb) {
        rfb.get_keyboard().ungrab()
        rfb.get_mouse().ungrab()
      }
    }
    $scope.focus = () => {
      if (rfb) {
        if (document.activeElement) {
          document.activeElement.blur()
        }
        rfb.get_keyboard().grab()
        rfb.get_mouse().grab()
      }
    }

    $attrs.$observe('url', (url) => {
      reset(url)
    })

    $scope.$on('$destroy', clean)
  })
  .directive('noVnc', function () {
    return {
      bindToController: true,
      controller: 'NoVncCtrl as noVnc',
      restrict: 'E',
      scope: {
        remoteControl: '=',
        onClipboardChange: '&'
      },
      template: view
    }
  })
  .name
