import angular from 'angular'
import Bluebird from 'bluebird'
// import filter from 'lodash.filter'
import foreach from 'lodash.foreach'
import keys from 'lodash.keys'
import union from 'lodash.union'

import xo from 'xo'
import xoNotify from 'xo-notify'

// ===================================================================

// TODO: remove when no longer used.
export default angular.module('xoWebApp.services', [
  xo,
  xoNotify
])
  // Alias the service for compatibility.
  .service('notify', (xoNotify) => xoNotify)
  .service('xoAggregate', function (xo, notify, bytesToSizeFilter) {
    function refreshStats (objects, level) {
      let statPromises
      statPromises = []
      foreach(objects, function (object) {
        const apiType = (object.type === 'host' && 'host') || (object.type === 'VM' && 'vm') || undefined
        if (!apiType) {
          notify.error({
            title: 'Unhandled object ' + (objects.name_label || ''),
            message: 'There is no stats available for this type of objects'
          })
          object._ignored = true
        } else {
          delete object._ignored
          statPromises.push(
            xo[apiType].refreshStats(object.id, level) // 2: week granularity (7 * 24 hours)
            .then(rawStats => {
              if (rawStats.stats === undefined) {
                object._ignored = true
                throw new Error('No stats')
              }

              return {object, rawStats}
            })
            .catch(error => {
              error.object = object
              object._ignored = true
              throw error
            })
          )
        }
      })
      // console.log('Promises length ', statPromises.length)
      return Bluebird
        .settle(statPromises)
        .then(function (stats) {
          let agglomeratedStats, statKeys
          statKeys = []
          agglomeratedStats = {
            details: {}
          }
          foreach(stats, function (statePromiseInspection) { // One object...
            if (statePromiseInspection.isRejected()) {
              notify.warning({
                title: 'Error fetching stats',
                message: 'Metrics do not include ' + statePromiseInspection.reason().object.name_label
              })
              return true // continue to next promise
            }

            if (!statePromiseInspection.isFulfilled()) {
              // neither rejected or accepted WTF ?
              notify.warning({
                title: 'Error fetching stats',
                message: 'Promises neither fulfilled or rejected'
              })
              return true
            }

            const {object, rawStats} = statePromiseInspection.value()

            // Make date array
            rawStats.stats.date = []

            let timestamp = rawStats.endTimestamp
            const nb = rawStats.stats.memory.length

            for (let i = nb - 1; i >= 0; i--) {
              rawStats.stats.date.unshift(timestamp)
              timestamp -= 3600
            }

            let metrics
            metrics = {}

            foreach(rawStats.stats, function (stat, statKey) {
              let statCounter, dateCounter, sum

              // Ignore date
              if (statKey === 'date') {
                return true
              }

              if (statKey === 'cpus') {
                metrics['All CPUs'] = []

                for (dateCounter = 0; dateCounter < nb; dateCounter++) {
                  const d = new Date(rawStats.stats.date[dateCounter] * 1000)
                  sum = 0
                  for (statCounter = 0; statCounter < stat.length; statCounter++) {
                    const v = computeValue(stat[statCounter][dateCounter])
                    sum += v
                  }

                  metrics['All CPUs'].push({
                    date: d,
                    value: sum / stat.length,
                    textValue: computeTextValue(object, statKey, sum / stat.length)
                  })
                }
              } else {
                if (Array.isArray(rawStats.stats[statKey])) {
                  // load, memory, memoryFree, memoryUsed
                  computeMetric(statKey, metrics, '', '', rawStats, stat, object, nb)
                } else {
                  // pifs, vifs, xvds
                  foreach(stat, function (realStat, type) {
                    foreach(realStat, function (value, index) {
                      computeMetric(statKey, metrics, index, type, rawStats, value, object, nb)
                    })
                  })
                }
              }
            })

            statKeys = union(statKeys, keys(metrics))
            agglomeratedStats.details[object.id] = metrics
          })
          // agglomerate objects stats
          agglomeratedStats.keys = statKeys.sort()
          /*
          foreach(statKeys, function (statKey) {
            let dateCounter, sum, d
            const objectWithstats = filter(agglomeratedStats.details, statKey)
            const nb = objectWithstats[0][statKey].length // I assume they're all the same length
            agglomeratedStats[statKey + '_sum'] = []
            agglomeratedStats[statKey + '_average'] = []
            for (dateCounter = 0; dateCounter < nb; dateCounter++) {
              sum = 0
              foreach(objectWithstats, function (objectWithStat) {
                sum += objectWithStat[statKey][dateCounter].value
                d = objectWithStat[statKey][dateCounter].date
              })
              agglomeratedStats[statKey + '_average'].push({
                date: d,
                value: sum / objectWithstats.length
              })
              agglomeratedStats[statKey + '_sum'].push({
                date: d,
                value: sum
              })
            }
          })*/
          // console.log(agglomeratedStats)
          return agglomeratedStats
        })

      function computeValue (value) {
        const v = parseFloat(value, 10)
        if (isNaN(v)) {
          return 0
        }
        return v
      }

      function computeMetric (statKey, metrics, index, type, rawStats, values, object, nb) {
        const metricName = computeMetricFullname(statKey, index, type)
        metrics[metricName] = []

        for (let dateCounter = 0; dateCounter < nb; dateCounter++) {
          const d = new Date(rawStats.stats.date[dateCounter] * 1000)
          const v = computeValue(values[dateCounter])
          const tv = computeTextValue(object, statKey, v)

          metrics[metricName].push({
            date: d,
            value: v,
            textValue: tv
          })
        }
      }

      function computeTextValue (object, statKey, value) {
        switch (statKey) {
          case 'vifs':
          case 'pifs':
          case 'xvds':
            return bytesToSizeFilter(value)
          case 'memoryUsed':
          case 'memory':
          case 'memoryFree':
            return bytesToSizeFilter(object.type === 'host' ? value * 1024 : value)
          default :
            return Math.round(value * 100) / 100
        }
      }

      function computeMetricFullname (statKey, index, type) {
        let metricName

        switch (statKey) {
          case 'vifs':
            metricName = 'Network ' + index + ' ' + ((type === 'rx') ? 'out' : 'in')
            break
          case 'pifs' :
            metricName = 'NIC ' + index + ' ' + ((type === 'rx') ? 'out' : 'in')
            break
          case 'xvds' :
            metricName = 'Disk ' + index + ' ' + ((type === 'r') ? 'read' : 'write')
            break
          case 'memoryUsed' :
            metricName = 'RAM (Used)'
            break
          case 'memory' :
            metricName = 'RAM (Total)'
            break
          case 'memoryFree' :
            metricName = 'RAM (Unused)'
            break
          case 'load' :
            metricName = 'Load average'
            break
          default :
            metricName = statKey + index
        }

        return metricName
      }
    }

    return {
      refreshStats
    }
  })
  .name
