'use strict'

import angular from 'angular'
import clone from 'lodash.clonedeep'
import foreach from 'lodash.foreach'
import d3 from 'd3'

export default angular.module('xoParallelD3', [])
  .directive('parallelChart', function ($parse) {
    function link (scope, element, attrs) {
      var traits,
        svg,
        width,
        height,
        x, y,
        line, g,
        foreground,
        axis,
        color,
        text,
        chart_data

      width = attrs.width ? parseInt(attrs.width, 10) : 2000
      height = attrs.height ? parseInt(attrs.height, 10) : width / 2/* breadcrumbs */

      line = d3.svg.line()
      axis = d3.svg.axis().orient('left')
      /* don't want decimals */
        .tickFormat(d3.format('d'))
        .tickSize(width / 100)
        .tickPadding(width / 300)

      color = d3.scale.category10()
       // took responsive svg trick from http://demosthenes.info/blog/744/Make-SVG-Responsive
      svg = d3.select(element[0])
        .append('div')
        /* padding from http://soqr.fr/testsvg/embed-svg-liquid-layout-responsive-web-design.php */
        .attr('style', 'position: relative;width: 90%;padding-bottom: 50%;margin-left:5%; vertical-align: middle;overflow: hidden;')
        .append('svg')
        .attr('style', 'display: block;position: absolute; top: 0;left: 0;')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('preserveAspectRatio', 'xMinYMin meet')
        .attr('viewBox', '0 0 ' + width + ' ' + height)
        .append('g')
        .attr('transform', 'translate(' + width / 20 + ',' + height / 10 + ')')
        .style('font-size', (width / 100) + 'px')/* since viewbox is 2000px , font should be big */

      scope.$watch(() => scope.chartData, function (newVal) {
        // purge existing graph ( no animation )
        svg
          .selectAll('.trait')
          .remove()

        svg
          .selectAll('.axis')
          .remove()

        svg
          .selectAll('.line')
          .remove()
        y = {}
        traits = []
        if (!scope.chartData && scope.chartData.length > 0) {
          return
        }

      // d3 add a lot of data to nodes. It triggers watch without rest
        chart_data = clone(scope.chartData)

        foreach(scope.chartLabels, function (labels, key) {
          traits.push(key)
        })

        x = d3.scale.ordinal().domain(traits).rangePoints([0, width * 0.9])
        // Create a scale and brush for each trait.
        foreach(traits, function (trait, idx) {
          // Coerce values to numbers.
          chart_data.forEach(function (datum) { datum[idx] = +datum[idx] })
          // force domain to start @ 0
          let domain
          domain = d3.extent(chart_data, function (datum) { return datum[trait] })
          domain[0] = domain[0] > 0 ? 0 : domain[0]

          y[trait] = d3.scale.linear()
              .domain(domain)
              .range([height, 0])

          y[trait].brush = d3.svg.brush()
              .y(y[trait])
              .on('brush', brush)
        })

      // Add foreground lines.
        foreground = svg.append('svg:g')
          .attr('class', 'foreground')
          .style({stroke: 'red', fill: 'none', 'stroke-opacity': 0.5, 'stroke-width': width / 500})
          .selectAll('path')
          .data(chart_data)
          .enter().append('svg:path')
          .attr('d', path)
          .attr('class', 'line')
          .attr('id', function (d) { return 'line-' + d.id })
          .attr('stroke', (node) => color(node.name))
          .attr('shape-rendering', 'optimizeQuality')
          .attr('stroke-linecap', 'round')
          .attr('stroke-linejoin', 'round')
          .on('mouseover', mouseover)
          .on('mouseout', () => highlight())
          .on('click', click)
      //  .attr('class', function(d) { return d.species; });

      // Add a draggable group element for each trait.
        const drag_behavior = d3
            .behavior
            .drag()
            .origin(function (d) { return {x: x(d)} })

        g = svg.selectAll('.trait')
          .data(traits)
          .enter().append('svg:g')
          .attr('class', 'trait')
          .attr('transform', function (d) { return 'translate(' + x(d) + ')' })
          .call(drag_behavior)

      // Add an axis and title.
        g.append('svg:g')
          .attr('class', 'axis')
          .each(function (d) { d3.select(this).call(axis.scale(y[d])) })
          .append('svg:text')
          .style('font-size', '125%')
          .style('font-weight', 'bold')
          .attr('text-anchor', 'middle')
          .attr('y', -50)
          .text((d) => scope.chartLabels[d])

        g.append('svg:g')
          .attr('class', 'brush')
          .each(function (d) { d3.select(this).call(y[d].brush) })
          .selectAll('rect')
          .attr('x', -width / 100)
          .attr('width', 2 * width / 100)

        svg.selectAll('.axis path, .axis line')
          .style({fill: 'none', stroke: '#000'})

        svg.selectAll('.brush .extent ')
          .style({'fill-opacity': 0.3, stroke: '#FFF'})
      })

      // Handles a brush event, toggling the display of foreground lines.
      function brush () {
        const actives = traits.filter(function (p) { return !y[p].brush.empty() })
        const extents = actives.map(function (p) { return y[p].brush.extent() })

        foreground.filter(function (d) {
          return !actives.every(function (p, i) {
            return extents[i][0] <= d[p] && d[p] <= extents[i][1]
          })
        })
          .attr('stroke-opacity', 0.05)
          .attr('stroke', '#000')

        foreground.filter(function (d) {
          return actives.every(function (p, i) {
            return extents[i][0] <= d[p] && d[p] <= extents[i][1]
          })
        })
          .attr('stroke-opacity', 0.5)
          .attr('stroke', (d) => color(d.name))
      }

      function mouseover (node) {
        highlight(node, d3.mouse(this))
        if (scope.over) {
          scope.over.apply(null, [{ d: node }])
        }
      }

      function click (node) {
        if (scope.click) {
          scope.click.apply(null, [{ d: node }])
        }
      }

      function highlight (node, position) {
        let node_id
        if (node) {
          node_id = node.id
        }
        if (text) {
          text.remove()
        }

        if (position) {
          let bbox, padding, t

          text = svg.append('svg:g')
          t = text.append('svg:text')
            .text(node.name)
            .attr('x', position[0])
            .attr('y', position[1] - 30)
            .style({'font-size': '125%', 'font-weight': 'bold', 'fill': 'white'})
          bbox = t.node().getBBox()
          padding = 10
          text.insert('svg:rect', '*')
            .attr('x', bbox.x - padding)
            .attr('y', bbox.y - padding)
            .attr('width', bbox.width + (padding * 2))
            .attr('height', bbox.height + (padding * 2))
            .style('fill', color(node.name))
            .style('stroke', 'white')
        }

        svg
          .selectAll('.line')
          .attr('stroke-width', width / 500)
        svg
          .select('#line-' + node_id)
          .attr('stroke-width', width / 200)
      }
  // Returns the path for a given data point.
      function path (d) {
        return line(
          traits.map(
            function (trait) {
              return [x(trait), y[trait](d[trait])]
            }
          )
        )
      }
    }

    return {
      resctict: 'E',
      replace: false,
      scope: {
        chartData: '=',
        chartLabels: '=',
        over: '&',
        click: '&'
      },
      link: link
    }
  })
  // A module exports its name.
  .name
