'use strict'

import angular from 'angular'
import clone from 'lodash.clonedeep'
import map from 'lodash.map'
import d3 from 'd3'
import xoBreadcrumbsD3 from 'xo-breadcrumbs-d3'

export default angular.module('xoSunburstD3', [xoBreadcrumbsD3])
  .directive('sunburstChart', function ($parse, $compile, $timeout) {
    function link (scope, element, attrs) {
      var width,
        height,
        radius,
        color_scale,
        $breadcrumbs,
        svg,
        arc,
        partition,
        textContainer

      scope.max_depth = 0
      width = attrs.width ? parseInt(attrs.width, 10) : 2000
      height = attrs.height ? parseInt(attrs.height, 10) : width + 50   /* breadcrumbs */
      radius = Math.min(width, height) / 2
      color_scale = d3.scale.category10()

      scope.breadcrumbsNodes = []
      $breadcrumbs = $compile('<breadcrumbs-d3 nodes="breadcrumbsNodes" max-depth="maxDepth"></breadcrumbs-d3>')(scope)
      element.append($breadcrumbs)
      textContainer = d3
        .select(element[0])
        .append('div')
        .attr('style', 'position:absolute;top:50%;margin-top:-15px;height:50%;left:0;right:0;  ')
        .append('div')
        .attr('class', 'text-value')
        .style('font-size', '30px')
        .style('text-align', 'center')

      // took responsive svg trick from http://demosthenes.info/blog/744/Make-SVG-Responsive
      svg = d3.select(element[0])
        .append('div')
        .attr('style', 'position: relative;width: 90%;padding-bottom: 100%;margin-left:5%; vertical-align: middle;overflow: hidden;')
        .append('svg')
        .attr('style', 'display: block;position: absolute; top: 0;left: 0;')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('preserveAspectRatio', 'xMinYMin meet')
        .attr('viewBox', '0 0 2000 2000')
        .append('g')
        .attr('transform', 'translate(' + width / 2 + ',' + height * 0.52 + ')')

      arc = d3.svg.arc()
        .startAngle((d) => d.x)
        .endAngle((d) => d.x + d.dx)
        .innerRadius((d) => Math.sqrt(d.y))
        .outerRadius((d) => Math.sqrt(d.y + d.dy))

      scope.$watch('selected', function (newVal) {
        if (newVal && newVal.id) {
          highlight(newVal.id)
        }
      })

      partition = d3.layout.partition()
        .sort(null)
        .size([2 * Math.PI, radius * radius])
        .value((d) => scope.log ? Math.log(d.size) : d.size)

      scope.$watch(() => scope.chartData, function (newVal) {
        var g, chart_data
        if (!scope.chartData || !scope.chartData.children || !scope.chartData.children.length) {
          svg
            .selectAll('path')
            .remove()
          scope.breadcrumbsNodes = []
          return
        }
        // update breadcrumbs and stuff
        highlight()

        // d3 add a lot of data to nodes. It triggers watch without rest
        chart_data = clone(scope.chartData)

        g = svg
          .datum(chart_data)
          .selectAll('path')
          .data(partition.nodes)

        g
          .enter()
          .append('path')
          .each(function (d) { this._current = { x: 0, dx: 0, y: 0, dy: 0 } }) // store the initial angles

        var existing_and_current = g
          .attr('display', (d) => d.depth ? null : 'none') // hide inner ring
          .attr('d', arc)
          .style('stroke', '#fff')
          .style('stroke-width', width / 200)
          .style('fill', color)
          .style('fill-rule', 'evenodd')
          .on('mouseover', mouseover)
          .on('click', click)

        // avoid locking the loop for animation
        setTimeout(function () {
          g
            .transition()
            .duration(750)
            .attrTween('d', arcTween)
            .each('end', function (node) {
              this._current = {
                x: node.x,
                dx: node.dx,
                y: node.y,
                dy: node.dy
              }
            })
        }, 0)

        existing_and_current
          .each(function (d) {
            if (d.depth > scope.max_depth) {
              scope.max_depth = d.depth
            }
          })
          .filter((d, i) => !!scope.click && !d.virtual)
          .style('cursor', 'pointer')

        g.exit().remove()
      }, true)

      function color (d) {
        if (d.color) {
          return d.color
        }
        return color_scale((d.children ? d : d.parent).name)
      }

      function arcTween (node) {
        if (!this._current) {
          this._current = { x: node.x, dx: 0, y: node.y, dy: 0 }
        }
        var i = d3.interpolate(this._current, node)
        return function (t) {
          return arc(i(t))
        }
      }
      function mouseover (d) {
        highlight(d.id)
        if (scope.over) {
          scope.over.apply(null, [{ d: d }])
        }
      }

      function click (d) {
        if (scope.click) {
          scope.click.apply(null, [{ d: d }])
        }
      }

      function highlight (id) {
        const sequenceArray = getAncestors(id)

        if (sequenceArray && sequenceArray.length) {
          textContainer.text(sequenceArray[sequenceArray.length - 1].textSize)
        }
        updateBreadcrumbs(sequenceArray)

        // Fade all the segments.
        svg.selectAll('path')
          .style('opacity', 0.6)

        // Then highlight only those that are an ancestor of the current segment.
        svg.selectAll('path')
          .filter(function (node) {
            return (sequenceArray.indexOf(node) >= 0)
          })
          .style('opacity', 1)
      }

      // Update the breadcrumb trail to show the current sequence .
      function updateBreadcrumbs (nodeArray) {
        const toBreadCrumbs = map(nodeArray, function (node) {
          return {name: node.name, fill: color(node)}
        })
        $timeout(function () {
          scope.breadcrumbsNodes = toBreadCrumbs
        }, 0)
      }

      function getAncestors (id) {
        var path = []
        svg.selectAll('path')
          .each(function (node) {
            if (node.id === id) {
              var current = node
              while (current.parent) {
                path.unshift(current)
                current = current.parent
              }
            }
          })
        return path
      }
    }

    return {
      resctict: 'E',
      replace: false,
      scope: {
        chartData: '=',
        selected: '=',
        log: '=',
        over: '&',
        click: '&'
      },
      link: link
    }
  })
  // A module exports its name.
  .name
