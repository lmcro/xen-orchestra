
'use strict'

import angular from 'angular'
import d3 from 'd3'
import find from 'lodash.find'
import forEach from 'lodash.foreach'

const $ = window.$

export default angular.module('xoHorizon', [])
.directive('horizon', function ($parse) {
  return {
    restrict: 'E',
    replace: false,
    scope: {
      chartData: '=',
      selected: '=',
      extent: '='
    },
    link: link
  }
  function link (scope, element, attrs) {
    let nbSteps, margin, width, height, color, data, $e

    nbSteps = attrs.steps || 4
    margin = {
      top: attrs.showAxis && attrs.axisOrientation !== 'bottom' ? 20 : 0,
      right: 20,
      bottom: attrs.showAxis && attrs.axisOrientation === 'bottom' ? 20 : 0,
      left: 20
    }
    width = getContainerWidth() - margin.left - margin.right
    height = attrs.height || 70 - margin.top - margin.bottom + (attrs.showAxis ? 20 : 0)
    color = attrs.color || 'darkgreen'

    const x = d3
      .time
      .scale()
      .range([0, width])
    const y = d3
      .scale.linear()
      .range([height, 0])

    const xAxis = d3
      .svg
      .axis()
      .scale(x)
      .orient(attrs.axisOrientation || 'top')

    const line = d3
      .svg
      .line()
      .x(function (d) {
        return x(d.date)
      })
      .y(function (d) {
        return y(d.value)
      })

    const bisectDate = d3
      .bisector(function (d) {
        return d.date
      }).left

    const svg = d3
      .select(element[0])
      .append('svg')
      .attr('height', height + margin.top + margin.bottom)
      .attr('width', width + margin.left + margin.right)
    .append('g')
    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

    // Tooltip
    const focus = svg
      .append('g')
      .attr('class', 'focus')
      .style('display', 'none')

    focus
      .append('text')
      .attr('x', 9)
      .attr('dy', '.35em')

    svg
      .append('rect')
      .attr('class', 'overlay')
      .attr('height', height)
      .attr('width', width)
      .style({fill: 'none', 'pointer-events': 'all'})
      .on('mousemove', mousemove)

    const hover = svg
      .append('g')
      .attr('class', 'hover-container')
      .style('pointer-events', 'none')

    hover
      .append('line')
      .attr('y1', 0)
      .attr('y2', height)
      .style('stroke-width', 2)
      .style('stroke-dasharray', '5 5')
      .style('stroke', 'red')
      .style('fill', 'none')

    hover
      .append('text')
      .style({fill: 'black'})

    function getContainerWidth () {
      $e = $(element[0]).parent()
      while ($e.width() === 0 && $e.parent()) {
        $e = $e.parent()
      }
      return $e.width()
    }
    function mousemove () {
      const x0 = x.invert(d3.mouse(this)[0])
      const index = bisectDate(data, x0, 1)
      const d0 = data[index - 1]
      const d1 = data[index]
      const d = x0 - d0.date > d1.date - x0 ? d1 : d0
      scope.$apply(function () {
        scope.selected = d.date
      })
    }

    function hoverDate (date) {
      const val = find(data, {date: date})
      if (val) {
        const value = val.textValue || Math.round(100 * val.value) / 100
        hover
          .select('line')
          .attr('x1', x(date))
          .attr('x2', x(date))
        hover
          .select('text')
          .attr('dx', x(date) + 5)
          .attr('dy', height / 2)
          .text(value)
      }
    }

    d3.selection.prototype.moveToFront = function () {
      return this.each(function () {
        this.parentNode.appendChild(this)
      })
    }

    function redraw () {
      let splittedData, counter, extent
      width = getContainerWidth() - margin.left - margin.right
      x.range([0, width])
      d3
        .select(element[0])
        .select('svg')
          .attr('width', width + margin.left + margin.right)
        .select('rect')
          .attr('width', width)

      extent = scope.extent || d3
        .extent(data, function (d) {
          return d.value
        })
      extent = [Math.min(0, extent[0]), Math.max(0, extent[1])]
      const intervalSize = (extent[1] - extent[0]) / nbSteps

      splittedData = []
      for (counter = 0; counter < nbSteps; counter++) {
        splittedData[counter] = []
        var d = new Date(data[0].date)
        splittedData[counter].push({
          date: d,
          value: 0
        })
      }
      forEach(data, function (datum) {
        for (counter = 0; counter < nbSteps; counter++) {
          let d, value
          d = new Date(datum.date)
          value = Math.min(Math.max(0, datum.value - intervalSize * counter), intervalSize)
          splittedData[counter].push({
            date: d,
            value: value,
            close: new Date(+d + 60 * 60 * 1000)
          })
        }
      })

      for (counter = 0; counter < nbSteps; counter++) {
        const d = new Date(data[data.length - 1].date)
        splittedData[counter].push({
          date: d,
          value: 0
        })
      }
      x.domain(d3.extent(splittedData[0], function (d) {
        return d.date
      }))
      y.domain([extent[0], extent[1] / nbSteps])

      svg.selectAll('.horizon-area').remove()
      if (label) {
        label.remove()
      }
      svg.selectAll('.axis').remove()
      if (attrs.showAxis) {
        var bottomaxis = svg
          .append('g')
          .attr('class', 'axis')
          .style({
            fill: 'none',
            stroke: '#000',
            'shape-rendering': 'crispEdges'
          })
          .call(xAxis)
        if (attrs.axisOrientation === 'bottom') {
          bottomaxis.attr('transform', 'translate(0,' + height + ')')
        }
        bottomaxis.selectAll('text').style({fill: 'black', stroke: 'transparent', 'font-size': '80%'})
      }
      forEach(splittedData, function (oneSplitted) {
        svg
        .append('path')
        .attr('class', 'horizon-area')
        .datum(oneSplitted)
        .style({
          fill: color,
          stroke: 'transparent',
          'fill-opacity': 0.25,
          'stroke-opacity': 0.3
        })
        .attr('d', line)
      })

      const label = svg.append('text')
        .style({
          'font-size': '125%'
        })
      const bbox = label.node().getBBox()
      label.attr('dx', 5)
        .attr('dy', (height + margin.bottom - bbox.height) / 2)
        .text(attrs.label)
      svg.select('.overlay').moveToFront()
      svg.select('.hover-container').moveToFront()
    }
    scope.$watch('selected', function (newVal) {
      if (newVal) {
        hoverDate(newVal)
      }
    })
    scope.$watch(function () {
      return scope.chartData
    }, function (newVal) {
      if (!newVal || !newVal.length) {
        return
      }
      data = newVal
      redraw()
    })

    scope.$watch(function () {
      return scope.extent
    }, function (newVal) {
      redraw()
    })
    $(window).resize(function () {
      redraw()
    })
  }
}).name
